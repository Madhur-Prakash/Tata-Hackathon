<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OpenStreetMap Demo</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        html, body { height: 100%; margin: 0; padding: 0; }
        
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #333;
            text-align: center;
            margin-bottom: 20px;
        }
        
        #map {
            height: 500px;
            width: 100%;
            border-radius: 8px;
            border: 2px solid #ddd;
        }
        
        .controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        
        button {
            padding: 10px 15px;
            background: #007cba;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #005a87;
        }
        
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        input[type="text"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            flex: 1;
            min-width: 200px;
        }
        
        input[type="number"] {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
            width: 150px;
        }
        
        .info {
            margin-top: 15px;
            padding: 10px;
            background: #e8f4f8;
            border-radius: 5px;
            border-left: 4px solid #007cba;
        }
        
        .status {
            margin-top: 10px;
            padding: 8px;
            background: #f9f9f9;
            border-radius: 4px;
            font-family: monospace;
            font-size: 12px;
        }
        
        .error {
            background: #ffebee;
            border-left: 4px solid #f44336;
            color: #c62828;
        }
        
        .success {
            background: #e8f5e8;
            border-left: 4px solid #4caf50;
            color: #2e7d32;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üó∫Ô∏è OpenStreetMap Interactive Demo</h1>
        
        <div id="map"></div>
        <div id="routeInfo" style="margin-top:10px; font-weight:bold;"></div>
        
        <div class="controls">
            <input type="text" id="searchInput" placeholder="Search for a location..." />
            <ul id="suggestions" style="list-style:none; padding-left:0; max-height:150px; overflow-y:auto; border:1px solid #ddd; margin-top:4px; display:none; background:#fff; border-radius:4px;"></ul>
            <button onclick="searchLocation()">Search</button>
            <button onclick="addMarker()">Add Marker</button>
            <button onclick="clearMarkers()">Clear Markers</button>
            <button onclick="getCurrentLocation()">My Location</button>
            <input type="number" id="batteryInput" placeholder="Battery level (%)" min="0" max="100" />
            <button onclick="updateBatteryLevel()">Set Battery</button>
            <button id="trackingBtn" onclick="toggleTracking()">Start Tracking</button>
        </div>
        
        <div class="info">
            <strong>Features:</strong> Click on the map to add markers, use the search to find locations, 
            or click "My Location" to center on your position. You can zoom and pan around the map freely.
            <div id="speedDisplay" style="margin-top: 10px; font-weight: bold;"></div>
            <div id="batteryDisplay" style="margin-top: 5px; font-weight: bold;">üîã Battery: 22%</div>
        </div>
        
        <div id="statusDisplay" class="status"></div>
    </div>

    <script>
        function loadLeaflet(callback) {
            const script = document.createElement('script');
            script.src = "https://cdn.jsdelivr.net/npm/leaflet@1.9.4/dist/leaflet.js";
            script.onload = callback;
            document.head.appendChild(script);
        }

        window.onload = function () {
            loadLeaflet(function () {
                initMap();
            });
        };
    </script>

    <script>
        let map;
        let markers = [];
        let lastPosition = null;
        let batteryLevel = 22;
        let watchId = null;
        let isTracking = false;
        let currentLocation = null;  // store user current location
        let routeLayer = null;       // layer to show route on map
        let userMarker = null;
        const routeInfoDisplay = document.getElementById('routeInfo');

        
        const speedDisplay = document.getElementById('speedDisplay');
        const batteryDisplay = document.getElementById('batteryDisplay');
        const statusDisplay = document.getElementById('statusDisplay');
        const trackingBtn = document.getElementById('trackingBtn');

        function initMap() {
            try {
                map = L.map('map').setView([51.505, -0.09], 13);
                L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '&copy; OpenStreetMap contributors'
                }).addTo(map);

                // Add click event to map
                map.on('click', function(e) {
                    const lat = e.latlng.lat;
                    const lng = e.latlng.lng;
                    
                    const marker = L.marker([lat, lng]).addTo(map);
                    marker.bindPopup(`<b>Coordinates:</b><br>Lat: ${lat.toFixed(5)}<br>Lng: ${lng.toFixed(5)}`);
                    markers.push(marker);
                });
                
                updateStatus("Map initialized successfully", "success");
            } catch (error) {
                updateStatus(`Map initialization error: ${error.message}`, "error");
            }
        }

        function updateStatus(message, type = "info") {
            const timestamp = new Date().toLocaleTimeString();
            statusDisplay.textContent = `[${timestamp}] ${message}`;
            statusDisplay.className = `status ${type}`;
            console.log(message);
        }

        function updateBatteryLevel() {
            const input = document.getElementById('batteryInput').value;
            const value = parseInt(input);

            if (!isNaN(value) && value >= 0 && value <= 100) {
                batteryLevel = value;
                batteryDisplay.textContent = `üîã Battery: ${batteryLevel}%`;
                updateStatus(`Battery level set to ${batteryLevel}%`, "success");
            } else {
                updateStatus('Please enter a valid battery level between 0 and 100.', "error");
            }
        }

        function toggleTracking() {
            if (isTracking) {
                stopTracking();
            } else {
                startTracking();
            }
        }

        function startTracking() {
            if (!navigator.geolocation) {
                updateStatus("Geolocation is not supported by this browser", "error");
                return;
            }

            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 1000
            };

            updateStatus("Starting location tracking...", "info");
            
            watchId = navigator.geolocation.watchPosition(
                handleLocationSuccess,
                handleLocationError,
                options
            );
            
            isTracking = true;
            trackingBtn.textContent = "Stop Tracking";
            trackingBtn.style.background = "#f44336";
        }

        function stopTracking() {
            if (watchId !== null) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            isTracking = false;
            trackingBtn.textContent = "Start Tracking";
            trackingBtn.style.background = "#007cba";
            updateStatus("Location tracking stopped", "info");
        }

        async function handleLocationSuccess(position) {
            try {
                // Validate position data
                if (!position || !position.coords) {
                    throw new Error("Invalid position data received");
                }

                const { latitude: lat, longitude: lng, accuracy } = position.coords;
                
                // Validate coordinates
                if (typeof lat !== 'number' || typeof lng !== 'number' || 
                    isNaN(lat) || isNaN(lng) || 
                    lat < -90 || lat > 90 || lng < -180 || lng > 180) {
                    throw new Error(`Invalid coordinates: lat=${lat}, lng=${lng}`);
                }

                updateStatus(`Location: ${lat.toFixed(6)}, ${lng.toFixed(6)} (¬±${accuracy?.toFixed(0)}m)`, "success");

                // Calculate speed if we have a previous position
                if (lastPosition && lastPosition.timestamp) {
                    const dist = haversine(lastPosition.lat, lastPosition.lng, lat, lng);
                    const timeDiff = (position.timestamp - lastPosition.timestamp) / 1000;
                    
                    if (timeDiff > 0) {
                        const speedMps = dist / timeDiff;
                        const speedKmph = speedMps * 3.6;
                        speedDisplay.textContent = `üöó Speed: ${speedKmph.toFixed(2)} km/h`;
                    }
                }

                lastPosition = {
                    lat,
                    lng,
                    timestamp: position.timestamp
                };

                // Send to backend (if available)
                await sendLocationUpdate(lat, lng);

            } catch (error) {
                updateStatus(`Location processing error: ${error.message}`, "error");
            }
        }

        function handleLocationError(error) {
            let message = "Location error: ";
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message += "Permission denied by user";
                    break;
                case error.POSITION_UNAVAILABLE:
                    message += "Position unavailable";
                    break;
                case error.TIMEOUT:
                    message += "Location request timed out";
                    break;
                default:
                    message += error.message || "Unknown error";
                    break;
            }
            updateStatus(message, "error");
        }

        async function sendLocationUpdate(lat, lng) {
            try {
                const response = await fetch('http://localhost:8000/api/location/update', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Accept': 'application/json'
                    },
                    body: JSON.stringify({
                        lat,
                        lng,
                        batteryLevel,
                        timestamp: Date.now()
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                
                if (data.redirectToChargingStation && data.station) {
                    const { lat: clat, lon: clon, name } = data.station;
                    
                    if (typeof clat === 'number' && typeof clon === 'number' && 
                        !isNaN(clat) && !isNaN(clon)) {
                        map.setView([clat, clon], 15);
                        const marker = L.marker([clat, clon]).addTo(map);
                        marker.bindPopup(`<b>üîã Nearest Charging Station</b><br>${name}`).openPopup();
                        markers.push(marker);
                        updateStatus(`Redirected to charging station: ${name}`, "success");
                    } else {
                        updateStatus("Invalid charging station coordinates received", "error");
                    }
                }
            } catch (error) {
                // Don't spam the status with backend errors, just log them
                console.warn('Backend communication error:', error.message);
            }
        }

        function haversine(lat1, lon1, lat2, lon2) {
            const R = 6371000; // Earth's radius in meters
            const toRad = (deg) => deg * Math.PI / 180;

            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat/2)**2 + 
                     Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2)**2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        const suggestionsList = document.getElementById('suggestions');

function showSearchSuggestions(locations) {
    suggestionsList.innerHTML = '';
    locations.forEach((loc, index) => {
        const li = document.createElement('li');
        li.style.padding = '8px';
        li.style.cursor = 'pointer';
        li.textContent = loc.display_name;
        li.addEventListener('click', () => {
            selectSuggestion(loc);
        });
        suggestionsList.appendChild(li);
    });
    suggestionsList.style.display = 'block';
}

function clearSuggestions() {
    suggestionsList.innerHTML = '';
    suggestionsList.style.display = 'none';
}

function selectSuggestion(location) {
    clearSuggestions();
    const lat = parseFloat(location.lat);
    const lng = parseFloat(location.lon);

    if (isNaN(lat) || isNaN(lng)) {
        updateStatus("Invalid coordinates in selected suggestion", "error");
        return;
    }

    map.setView([lat, lng], 15);

    // Clear existing route if any
    if (routeLayer) {
        map.removeLayer(routeLayer);
        routeLayer = null;
    }

    // Show marker at destination
    const marker = L.marker([lat, lng]).addTo(map);
    marker.bindPopup(`<b>${location.display_name}</b>`).openPopup();
    markers.push(marker);

    updateStatus(`Selected location: ${location.display_name}`, "success");

    // Draw route if current location known
    if (currentLocation) {
        drawRoute(currentLocation.lat, currentLocation.lng, lat, lng);
    }
}




        async function drawRoute(lat1, lon1, lat2, lon2) {
    updateStatus("Calculating optimized route...", "info");

    const osrmUrl = `https://router.project-osrm.org/route/v1/driving/${lon1},${lat1};${lon2},${lat2}?overview=full&geometries=geojson`;

    try {
        const res = await fetch(osrmUrl);
        if (!res.ok) {
            throw new Error(`Routing API error: ${res.status}`);
        }

        const data = await res.json();
        if (data.code !== "Ok" || !data.routes || data.routes.length === 0) {
            throw new Error("No route found");
        }

        const route = data.routes[0];
        const coords = route.geometry.coordinates.map(c => [c[1], c[0]]); // flip lon-lat to lat-lon for Leaflet

        // Remove existing route
        if (routeLayer) {
            map.removeLayer(routeLayer);
        }

        routeLayer = L.polyline(coords, { color: 'blue', weight: 5, opacity: 0.7 }).addTo(map);

        // Fit map bounds to route
        map.fitBounds(routeLayer.getBounds());
        routeInfoDisplay.textContent = `Distance: ${(route.distance/1000).toFixed(2)} km | Estimated time: ${(route.duration/60).toFixed(1)} min`;

        updateStatus(`Route found: ${(route.distance/1000).toFixed(2)} km, estimated time: ${(route.duration/60).toFixed(1)} min`, "success");
    } catch (error) {
        updateStatus(`Error drawing route: ${error.message}`, "error");
    }
}


function addOrUpdateUserMarker(lat, lng) {
    if (userMarker) {
        userMarker.setLatLng([lat, lng]);
    } else {
        userMarker = L.marker([lat, lng], {icon: L.icon({
            iconUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-icon.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
            shadowSize: [41, 41]
        })}).addTo(map).bindPopup('<b>Your Location</b>').openPopup();
    }
}

        async function searchLocation() {
    const query = document.getElementById('searchInput').value.trim();
    if (!query) {
        updateStatus("Please enter a search query", "error");
        return;
    }

    // If current location unknown, ask for permission first
    if (!currentLocation) {
        if (!navigator.geolocation) {
            updateStatus("Geolocation not supported", "error");
            return;
        }
        updateStatus("Requesting current location permission...", "info");
        try {
            currentLocation = await new Promise((resolve, reject) => {
                navigator.geolocation.getCurrentPosition(resolve, reject, { enableHighAccuracy: true });
            });
            currentLocation = {
                lat: currentLocation.coords.latitude,
                lng: currentLocation.coords.longitude
            };
            // Add/update user location marker:
            addOrUpdateUserMarker(currentLocation.lat, currentLocation.lng);
            updateStatus(`Current location obtained: ${currentLocation.lat.toFixed(6)}, ${currentLocation.lng.toFixed(6)}`, "success");
        } catch (error) {
            updateStatus("Permission denied or error obtaining location", "error");
            return;
        }
    }

    try {
        updateStatus("Searching for location...", "info");

        // Use Nominatim with India bounding box for priority
        // India bbox approx: 6.5546,68.1114 (SW) to 35.6745,97.3956 (NE)
        // Format for viewbox param: left,top,right,bottom = lon1,lat1,lon2,lat2 but Nominatim wants left,top,right,bottom with lat and lon swapped
        const indiaViewbox = "68.1114,35.6745,97.3956,6.5546"; // left, top, right, bottom in lon,lat
        // We'll use bounded=1 to restrict results within viewbox and limit=5 for suggestions
        const url = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&viewbox=${indiaViewbox}&bounded=1&limit=5&addressdetails=1`;

        const response = await fetch(url);

        if (!response.ok) {
            throw new Error(`Search failed: ${response.status}`);
        }

        const data = await response.json();

        if (data.length === 0) {
            updateStatus('Location not found within India!', "error");
            return;
        }

        // Show suggestions in a simple dropdown below the search box
        showSearchSuggestions(data);

    } catch (error) {
        updateStatus(`Search error: ${error.message}`, "error");
    }
}


        function addMarker() {
            try {
                const center = map.getCenter();
                const marker = L.marker([center.lat, center.lng]).addTo(map);
                marker.bindPopup(`<b>Manual Marker</b><br>Lat: ${center.lat.toFixed(5)}<br>Lng: ${center.lng.toFixed(5)}`);
                markers.push(marker);
                updateStatus("Marker added at map center", "success");
            } catch (error) {
                updateStatus(`Error adding marker: ${error.message}`, "error");
            }
        }

        function clearMarkers() {
            try {
                markers.forEach(marker => {
                    map.removeLayer(marker);
                });
                markers = [];
                updateStatus(`Cleared ${markers.length} markers`, "success");
            } catch (error) {
                updateStatus(`Error clearing markers: ${error.message}`, "error");
            }
        }

        function getCurrentLocation() {
    if (!navigator.geolocation) {
        updateStatus('Geolocation is not supported by this browser', "error");
        return;
    }

    updateStatus("Getting current location...", "info");

    navigator.geolocation.getCurrentPosition(
        function(position) {
            try {
                const lat = position.coords.latitude;
                const lng = position.coords.longitude;

                if (isNaN(lat) || isNaN(lng)) {
                    throw new Error("Invalid coordinates received");
                }

                currentLocation = { lat, lng };
                addOrUpdateUserMarker(lat, lng);

                map.setView([lat, lng], 15);

                const marker = L.marker([lat, lng]).addTo(map);
                marker.bindPopup('<b>Your Location</b>').openPopup();
                markers.push(marker);

                updateStatus(`Current location: ${lat.toFixed(6)}, ${lng.toFixed(6)}`, "success");
            } catch (error) {
                updateStatus(`Error processing location: ${error.message}`, "error");
            }
        },
        function(error) {
            handleLocationError(error);
        },
        { enableHighAccuracy: true, timeout: 10000 }
    );
}

        // Allow Enter key for search
        document.getElementById('searchInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                searchLocation();
            }
        });

        // Initialize battery display
        batteryDisplay.textContent = `üîã Battery: ${batteryLevel}%`;
    </script>
</body>
</html>